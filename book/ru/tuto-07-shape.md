# Более сложная форма

Вместо того, чтобы рисовать треугольник, мы собираемся нарисовать более сложную форму: чайник.
Чайник из Юты - это знаменитая трехмерная модель, которую часто считают одним из "hello world" в графическом программировании.

В реальном приложении сложные модели (под «сложными» я подразумеваю нечто большее, чем несколько вершин)
загружаются из файлов во время выполнения. Но для целей этого урока мы будем использовать Rust
файл, содержащий уже подготовленную модель.
[**Вы можете найти это тут**](../tuto-07-teapot.rs).

Этот файл содержит три массива:

 - Массив позиций вершин (называемый `VERTICES`).
 - Массив, содержащий нормали (`NORMALS`) каждой вершины. Нормаль вершины - это вершина, перпендикулярная форме объекта в этой точке. Мы собираемся это загрузить, но использовать его будем только в следующих уроках.
 - Массив, содержащий индексы (`INDICES`).

Все фигуры в графическом программировании сделаны из треугольников. В реальной трехмерной модели несколько треугольников часто используют одну и ту же вершину, поэтому, чтобы избежать дублирования вершин, мы храним список треугольников и список вершин отдельно.

Каждый элемент `INDICES` фактически является индексом в массивах `VERTICES` и `NORMALS`, и каждая группа из трех индексов образует треугольник. Например, первые три элемента `INDICES` - это 7, 6 и 1. Это объявляет треугольник, который соединит вершины 7, 6 и 1, данные которых находятся в `VERTICES` и `NORMALS`.

## Загрузка формы

Мы собираемся использовать файл Rust, содержащий модель, в качестве модуля с именем `teapot`.

```rust
mod teapot;
```

Загрузка данных в этом случае очень проста:

```rust
let positions = glium::VertexBuffer::new(&display, &teapot::VERTICES).unwrap();
let normals = glium::VertexBuffer::new(&display, &teapot::NORMALS).unwrap();
let indices = glium::IndexBuffer::new(&display, glium::index::PrimitiveType::TrianglesList,
                                      &teapot::INDICES).unwrap();
```

У нас есть новый тип: `IndexBuffer`. Как видно из его названия, это буфер, целью которого является хранение индексов. Когда мы создаем его, мы должны указать тип примитивов, которые находятся внутри буфера, в данном случае это список треугольников. Существует несколько видов примитивов, но список треугольников является наиболее распространенным.

## Программа

Нам нужно внести несколько изменений в вершинный шейдер.

Вместо одного мы получим два атрибута: `position` и `normal`. Кроме того, `position` теперь является `vec3` вместо `vec2`.

```glsl
#version 140

in vec3 position;
in vec3 normal;

uniform mat4 matrix;

void main() {
    gl_Position = matrix * vec4(position, 1.0);
}
```

Значение, которое мы устанавливаем в переменную `gl_Position`, является положением вершины в координатах окна. Почему в нем четыре компонента? Вот ответ:

 - Пространство координат окна на самом деле в 3D! OpenGL рассматривает наш экран как трехмерный.
 - Первые три координаты делятся на четвертую координату сразу после выполнения нашего вершинного шейдера. Четвертая координата затем отбрасывается.

Например, если мы выведем `gl_Position = vec4 (2.0, -4.0, 6.0, 2.0);`, графический процессор разделит первые три координаты на `2.0` и получит `(1.0, -2.0, 3.0)`, которые являются координаты экрана.

Первые две координаты (`1.0` и` -2.0`) затем представляют положение вершины на экране, а третьи (`3.0`) представляют глубину вершины. Это значение глубины на данный момент отбрасывается, но мы будем использовать его в следующем уроке.

Что касается фрагментного шейдера, давайте сейчас просто выведем красный цвет:

```glsl
#version 140

out vec4 color;

void main() {
    color = vec4(1.0, 0.0, 0.0, 1.0);
}
```

## Отрисовка

По сравнению с предыдущими разделами, есть два отличия при отрисовки:

 - У нас есть два буфера вершин. Это решается передачей кортежей буферов. Первый параметр функции `draw` должен реализовывать `MultiVerticesSource` trait, которая включает в себя одиночные буферы и кортежи буферов.
 - У нас есть индексы, поэтому мы передаем ссылку на наш индексный буфер в функцию `draw`.

```rust
let matrix = [
    [1.0, 0.0, 0.0, 0.0],
    [0.0, 1.0, 0.0, 0.0],
    [0.0, 0.0, 1.0, 0.0],
    [0.0, 0.0, 0.0, 1.0f32]
];

target.draw((&positions, &normals), &indices, &program, &uniform! { matrix: matrix },
            &Default::default()).unwrap();
```

И если вы выполните этот код, вы увидите ...

![Результат](../tuto-07-wrong.png)

...подожте, что-то не так!

В графическом программировании очень часто возникают такие проблемы, когда вы не всегда понимаете, что происходит. Попробуйте угадать, в чем здесь проблема!

Ответ здесь заключается в том, что модель слишком велика, чтобы поместиться на экране. Координаты модели находятся в диапазоне приблизительно от `-100` до `+100`, но логические координаты нашего экрана находятся в диапазоне от `-1.0` до `1.0`. Чтобы исправить это, давайте настроим нашу матрицу, чтобы изменить масштаб модели до 1/100 ее размера:

```rust
let matrix = [
    [0.01, 0.0, 0.0, 0.0],
    [0.0, 0.01, 0.0, 0.0],
    [0.0, 0.0, 0.01, 0.0],
    [0.0, 0.0, 0.0, 1.0f32]
];
```

И теперь вы должны получить правильный результат:

![Правильный результат](../tuto-07-correct.png)

Это выглядит очень примитивно, но это хороший первый шаг к 3D-рендерингу.

**[Вы можете найти весь исходный код здесь](https://github.com/glium/glium/blob/master/examples/tutorial-07.rs).**
