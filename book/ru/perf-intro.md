# Производительность

Вот примерная стоимость различных операций:

 - **Создание `Program`**: очень высокая, так как драйвер должен компилировать исходный код программы. Делайте это только при инициализации.

 - **Создание пустого буфера**: средняя для вершинных и индексных буферов, низкая для других буферов.

 - **Загрузка данных в буфер**: от низкой до средней. Скорость передачи между ОЗУ и видеопамятью сегодня составляет около 15 ГБ в секунду. Это означает, что загрузка 1 МБ данных занимает около 65 мкс. Реализация OpenGL также иногда может дать вам буфер, данные которого находятся в оперативной памяти, и в этом случае вы платите цену при рисовании, а не при загрузке.

 - **Копирование между двумя буферами**: очень низкая (похоже на memcpy на процессоре). Эта операция выполняется асинхронно с помощью графического процессора или прямого доступа к памяти. Скорость передачи составляет около 50 ГБ в секунду.

 - **Создание текстуры**: низкая. Повторное использование существующей текстуры быстрее, чем создание новой, но не намного.

 - **Загрузка данных в текстуру**: от низкой до высокой. Если данные, которые вы предоставляете OpenGL, соответствуют внутреннему формату текстуры, тогда стоимость равна загрузке данных в буфер. Однако, если данные имеют неправильный формат, тогда графический процессор должен выполнять преобразования.

 - **Перенос между пиксельным буфером и текстурой**: от очень низкой до очень высокой. Это похоже на "Загрузка данных в текстуру". Если данные соответствуют внутреннему формату текстуры, то это просто передача между видеопамятью. Если данные не соответствуют формату, то реализация OpenGL будет считывать текстуру / буфер в ОЗУ, выполнять преобразования, а затем загружать данные в текстуру / буфер.

 - **Вызов отрисовки**: средняя. Вызов на отрисовку имеет фиксированную стоимость на процессоре, и переменную стоимость на графическом процессоре. Чтобы уменьшить эту фиксированную стоимость, вы должны группировать вызовы вместе, если можете. Например, лучше нарисовать десять спрайтов, написав двадцать треугольников в одном буфере вершин и отправив только одну команду вместо десяти.

 - **Замена буферов**: очень низкая / переменный. Процесс замены буферов в конце кадра очень быстрый. Однако если вы сравните этот вызов функции, вы, вероятно, увидите, что это занимает много времени. Причина в том, что реализация OpenGL обычно не отправляет команды в GPU сразу. Вместо этого он добавляет команды в локальную очередь, а затем сразу отправляет куски команд. Когда вы меняете местами буферы, реализация сбрасывает свою локальную очередь и отправляет все свои команды в графический процессор. В дополнение к этому, также обратите внимание, что vsync может блокировать обмен буферов до тех пор, пока экран не обновится.

## Предотвращение изменений состояния

Выполнение нескольких вызовов отрисовки подряд с одинаковыми параметрами (один и тот же источник вершин, одна и та же программа, одинаковые параметры прорисовки, одинаковые формы) выполняется быстрее, чем переключение параметров.

Точнее:

 - Изменение формы основных типов (с плавающей точкой, целых чисел и т. Д.) Между двумя вызовами отрисовки: низкий.

 - Изменение формы текстуры между двумя вызовами отрисовки: средняя.

 - Изменение параметров отрисовки между двумя вызовами отрисовки: средняя.

 - Изменение источника вершин между двумя вызовами отрисовки: средняя.

 - Изменение программы между двумя вызовами отрисовки: высокая.

 - Изменение цели рендеринга между двумя вызовами отрисовки: высокая.

Поэтому, если у вас много вещей для рисования, вы должны группировать объекты по программам, рисовать параметры и источник вершин.
