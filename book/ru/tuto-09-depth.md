# Проверка глубины

Что не так с чайником из предыдущего раздела?

![Чайник](../tuto-08-result.png)

Проблема в том, что грани, которые находятся на задней части модели, отображаются *над* гранями, которые находятся на передней части модели.

![Проблема](../tuto-09-problem.png)

Это может показаться глупой проблемой, но графические процессоры - это не что иное, как компьютеры, и компьютеры делают только то, что вы им говорите.

Точнее, получается, что треугольники нарисованы один над другим в том порядке, в котором они указаны. Таким образом, последние вершины списка всегда будут впереди.

## Использование значения глубины

Два раздела назад мы увидели, что означает значение `gl_Position`. Третье значение этой переменной содержит глубину вершины на экране. Чем больше значение, тем дальше от экрана находится вершина.

На данный момент это значение просто отбрасывается графическим процессором, но теперь мы попросим его использовать это значение, чтобы определить, какой пиксель должен быть видимым.

Эта функциональность добавляет шаг в конвейер рендеринга. После того, как фрагментный шейдер был вызван, GPU затем возьмет значение глубины этого фрагмента (интерполированное из глубины окружающих вершин) и сравнит его с глубиной пикселя, который уже находится на экране. Если глубина ниже существующего значения, пиксель записывается, а значение глубины обновляется. Если это не так, пиксель отбрасывается.

Благодаря этому методу, когда несколько пикселей перекрываются, останется только пиксель, значение глубины которого является наименьшим. Это также означает, что вы можете рисовать несколько объектов (например, несколько чайников), не заботясь о порядке их рисования.

## Код

Нам нужно изменить три вещи:

 - При инициализации нам нужно попросить glutin создать буфер глубины, который будет содержать значение глубины каждого пикселя.
 - Перед каждым кадром мы должны сбросить содержимое буфера глубины до `1.0` (что является максимальным значением). Это похоже на то, когда мы сбрасываем цвет на синий.
 - При рисовании мы должны передать дополнительные параметры, чтобы попросить графический процессор выполнить эту проверку глубины.

Первый шаг состоит в изменении кода построения контекста:

```rust
let context = glutin::ContextBuilder::new().with_depth_buffer(24);
```

Мы просим систему выделить буфер глубиной 24 бита. 24 бита - это очень распространенное значение, которое используется очень часто. Проверка глубины является важной функцией любой системы рендеринга, поэтому буферы глубины должны поддерживаться везде.

Для второго шага нам нужно изменить эту строку:

```rust
target.clear_color(0.0, 0.0, 1.0, 1.0);
```

На эту:

```rust
target.clear_color_and_depth((0.0, 0.0, 1.0, 1.0), 1.0);
```

Это просит бэкэнд заполнить буфер глубины значением `1.0`. Обратите внимание, что это *логическое* значение, и допустим только диапазон от `0.0` до `1.0`. Фактическим содержимым буфера является максимальное представимое число. Для буфера глубиной 24 бита это `16777215`.

Третий шаг заключается в передаче дополнительного параметра при рисовании. Проверка глубины и обработка буфера глубины выполняется непосредственно оборудованием, а не нашим шейдером. Поэтому нам нужно указать бэкэнду, что он должен делать, из списка возможных операций.

```rust
let params = glium::DrawParameters {
    depth: glium::Depth {
        test: glium::draw_parameters::DepthTest::IfLess,
        write: true,
        .. Default::default()
    },
    .. Default::default()
};

target.draw((&positions, &normals), &indices, &program,
            &uniform! { matrix: matrix, u_light: light }, &params).unwrap();
```

Параметр `test` указывает, что пиксели следует хранить только в том случае, если их значение глубины уступает существующему значению глубины в буфере глубины. Параметр `write` указывает, что значение глубины пикселей, которые проходят проверку, должно быть записано в буфер глубины. Если мы не установим для `write` значение true, содержимое буфера глубины всегда будет оставаться на уровне `1.0`.

`Depth` структура имеет два других члена, которые не будут рассмотрены здесь. Точно так же структура `DrawParameters` имеет много членов, которые описывают различные части процесса рендеринга. Эта структура будет использоваться в будущем.

И вот результат:

![Результат](../tuto-09-result.png)

Если вы используете отладчик OpenGL, вы можете увидеть содержимое буфера глубины, где значения представлены в оттенках серого. Вот наш буфер глубины после рисования чайника:

![Буфер глубины](../tuto-09-depth.png)

**[Вы можете найти весь исходный код здесь](https://github.com/glium/glium/blob/master/examples/tutorial-09.rs).**
