# Отрисовка треугольника

За некоторыми исключениями (например, операция очистки, которая использовалась выше), OpenGL не предоставляет функции для простого рисования фигур. Например, нет функции `draw_rectangle`, `draw_cube` или `draw_text`. Вместо этого все обрабатывается одинаково: через графический конвейер. Неважно, рисуете ли вы простой треугольник или трехмерную модель с тысячами полигонов и продвинутыми методами затенения, все использует одну и ту же механику.

Это точка, в которой порог входа становится достаточно высоким, так как вам нужно узнать, как работает графический конвейер, даже если вы просто хотите нарисовать один треугольник. Однако, как только вы пройдете этот шаг, вам станет легче понимать все остальное.

Прежде чем мы сможем нарисовать треугольник, нам нужно подготовить две вещи во время инициализации:

 - Форму, которая описывает наш треугольник.
 - Программу, которую будет выполнять GPU.

## Форма

Форма представляет геометрию объекта. Когда вы думаете о «геометрии», вы можете думать о квадратах, кругах и так далее, но в графическом программировании единственными фигурами, которыми мы собираемся манипулировать, являются треугольники (примечание: тесселяция открывает возможность использовать другие многоугольники, но это более сложная тема).

Вот пример формы объекта. Как видите, он состоит из сотен треугольников и только треугольников.

![Знаменитый чайник Юта](../tuto-02-teapot.png)

Каждый треугольник состоит из трех вершин, что означает, что фигура - это просто набор вершин, соединенных вместе для образования треугольников. Первым шагом для описания такой формы с помощью glium является создание структуры с именем `Vertex` (фактическое имя не имеет значения), целью которой является описание каждой отдельной вершины. Наша коллекция вершин может быть позже представлена как `Vec<Vertex>`.

```rust
#[derive(Copy, Clone)]
struct Vertex {
    position: [f32; 2],
}

implement_vertex!(Vertex, position);
```

Наша структура содержит поле `position`, которое мы будем использовать для хранения положения каждой вершины в окне. Являясь настоящим векторным рендером, OpenGL не использует координаты в пикселях. Вместо этого он считает, что окно имеет ширину и высоту 2 единицы, а источник находится в центре окна.

![Координатная система окна](../tuto-02-window-coords.svg)

Когда мы даем позиции OpenGL, нам нужно использовать эту систему координат. Давайте выберем форму для нашего треугольника, например эту:

![Нахождение координат нашего треугольника](../tuto-02-triangle-coords.svg)

Что в коде выглядит следующим образом:

```rust
let vertex1 = Vertex { position: [-0.5, -0.5] };
let vertex2 = Vertex { position: [ 0.0,  0.5] };
let vertex3 = Vertex { position: [ 0.5, -0.25] };
let shape = vec![vertex1, vertex2, vertex3];
```

Теперь у нас есть форма! Последний шаг заключается в загрузке этой фигуры в память нашей видеокарты в так называемый *буфер вершин* для более быстрого доступа. Даже если это не является строго необходимым, это очень легко сделать, и это значительно ускорит процесс рисования.

```rust
let vertex_buffer = glium::VertexBuffer::new(&display, &shape).unwrap();
```

Более сложные формы состоят из сотен или тысяч вершин. Нам нужен не только список вершин, но и способ рассказать OpenGL, как связать эти вершины вместе, чтобы получить треугольники. Поскольку у нас есть только один треугольник, это не очень важно для нас, поэтому мы просто создаем фиктивный маркер, который позже мы передадим в glium.

```rust
let indices = glium::index::NoIndices(glium::index::PrimitiveType::TrianglesList);
```

## Программа

Когда OpenGL был впервые создан в 1990-х годах, рисование объекта просто состояло в отправке формы вместе с различными параметрами, такими как цвет, направление освещения, расстояние тумана и так далее. Но эти параметры быстро стали слишком ограничивающими для создателей игр, и когда в OpenGL 2 выпустили более гибкую систему, добавили так называемые *шейдеры*. Когда OpenGL 3 был выпущен несколько лет спустя, все эти параметры были удалены и полностью заменены шейдерами.

Чтобы нарисовать треугольник, вам понадобится некоторое общее представление о том, как работает процесс рисования (также называемый *конвейером*).

![Графический конвеер](../tuto-02-pipeline.svg)

Список координат слева от схемы представляет вершины фигуры, которую мы создали ранее. Когда мы попросим графический процессор нарисовать эту форму, он сначала выполнит то, что называется *вершинным шейдером*, один раз для каждой вершины (в нашем случае 3 раза, так как 3 вершины). Вершинный шейдер - это небольшая программа, целью которой является сообщить графическому процессору, каковы координаты каждой вершины на экране (от -1 до 1, как было сказано ранее). Затем графический процессор строит наш треугольник и определяет, какие пиксели экрана находятся внутри него. Затем он выполнит *фрагментный шейдер* один раз для каждого из этих пикселей. Фрагментный шейдер - это небольшая программа, цель которой - сообщить графическому процессору, какой цвет должен быть у каждого пикселя.

Сложность в том, что *нам* нужно написать вершинный и фрагментный шейдеры самостоятельно. Для этого мы должны использовать язык программирования *GLSL*, который очень похож на язык программирования Си. Обучать вас GLSL было бы слишком сложно на данный момент, поэтому я просто дам вам исходные коды. Вот исходный код, который мы будем использовать для вершинного шейдера:

```rust
let vertex_shader_src = r#"
    #version 140

    in vec2 position;

    void main() {
        gl_Position = vec4(position, 0.0, 1.0);
    }
"#;
```

Прежде всего, строка `#version 140` предназначена для того, чтобы сообщить OpenGL, какой версии GLSL соответствует этот исходный код. Некоторое оборудование не поддерживает последние версии GLSL, поэтому мы стараемся придерживаться более ранних версий, если это возможно.

Когда мы определили структуру `Vertex` в нашей форме, мы создали поле с именем` position`, которое содержит положение нашей вершины. Но вопреки тому, что я позволил вам подумать, эта структура не содержит фактической позиции вершины, а только атрибут, значение которого передается вершинному шейдеру. OpenGL не заботится об имени атрибута, все, что он делает, это передает его значение вершинному шейдеру. Строка `in vec2 position;` нашего шейдера здесь для того, чтобы объявить, что мы ожидаем, что нам будет передан атрибут с именем `position`, тип которого `vec2` (который соответствует типу `[f32; 2]` в Rust).

Функция `main` нашего шейдера вызывается один раз для каждой вершины, что означает три раза для нашего треугольника. В первый раз значение `position` будет `[-0.5, -0.5]`, во второй раз оно будет `[0, 0.5]`, а в третий раз `[0.5, -0.25]`. Именно в этой функции мы фактически сообщаем OpenGL, какова позиция нашей вершины, благодаря строке `gl_Position = vec4(position, 0.0, 1.0);`. Нам нужно сделать небольшое преобразование, потому что OpenGL ожидает не двумерные координаты, а *четырехмерные* координаты (причина этого будет рассмотрена в следующем уроке).

Второй шейдер называется фрагментным шейдером (иногда его также называют *пиксельным шейдером*).

```rust
let fragment_shader_src = r#"
    #version 140

    out vec4 color;

    void main() {
        color = vec4(1.0, 0.0, 0.0, 1.0);
    }
"#;
```

Этот исходный код очень похож на наш вершинный шейдер выше. На этот раз функция `main` выполняется один раз для каждого пикселя и должна возвращать цвет этого пикселя, что мы делаем со строкой `color = vec4(1.0, 0.0, 0.0, 1.0);`. Как и в случае с `clear_color` ранее, нам нужно передать красный, зеленый, синий и альфа-компоненты пикселя. Здесь мы возвращаем непрозрачный красный цвет. Можно вернуть разные значения в зависимости от пикселя, но это будет рассмотрено в следующих уроках.

Теперь, когда мы написали исходные коды наших шейдеров, давайте отправим их в библиотеку glium:

```rust
let program = glium::Program::from_source(&display, vertex_shader_src, fragment_shader_src, None).unwrap();
```

## Отрисовка

Теперь, когда мы подготовили нашу форму и программу, мы можем наконец отрисовать этот треугольник!

Помните объект `target`? Нам нужно будет использовать его, чтобы начать операцию рисования.

```rust
let mut target = display.draw();
target.clear_color(0.0, 0.0, 1.0, 1.0);
// рисуем треугольник здесь
target.finish().unwrap();
```

Для запуска операции рисования требуется несколько вещей: источник вершин (здесь мы используем наш `vertex_buffer`), источник индексов (мы используем нашу переменную `indexes`), программу, униформу программы и некоторые параметры рисования. Мы объясним, что такое униформа и параметры рисования, в следующих уроках, но на данный момент мы просто проигнорируем их, пропустив маркер EmptyUniforms и оставив параметры рисования по умолчанию.

```rust
target.draw(&vertex_buffer, &indices, &program, &glium::uniforms::EmptyUniforms,
            &Default::default()).unwrap();
```

Обозначение «команда рисования» может заставить вас думать, что рисование - это тяжелая операция, которая занимает много времени. На самом деле рисование треугольника занимает меньше нескольких микросекунд, и если все идет хорошо, вы должны увидеть симпатичный маленький треугольник:

![Наш конечный результат](../tuto-02-triangle.png)

**[Вы можете найти весь исходный код здесь](https://github.com/glium/glium/blob/master/examples/tutorial-02.rs).**
