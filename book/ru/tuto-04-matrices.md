
# Матрицы

Мы перемещаем наш треугольник слева направо на экране простым добавлением. Но как насчет других преобразований, таких как повороты, перекосы или изменения размеров?

Все геометрические операции, которые нам нужны, могут быть выполнены с помощью математики:

 - Масштабирование нашего треугольника сделано как `position *= factor;`
 - Вращение нашего треугольника сделано как `new_position = vec2(pos.x * cos(angle) - pos.y * sin(angle), pos.x * sin(angle) + pos.y * cos(angle));`
 - Перекос нашего треугольника сделан как `position.x += position.y * factor;`

Но что, если мы хотим сделать поворот, затем пермещение, а затем изменить масштаб? Или перекос и поворот? Хотя это можно сделать с помощью математики, все становится очень сложным для обработки.

Вместо этого программисты используют **матрицы**. Матрица - это двумерная таблица чисел, которая *может представлять геометрическое преобразование*. В компьютерной графике мы используем матрицы 4х4.

Вернемся к нашему движущемуся треугольнику. Мы собираемся изменить вершинный шейдер, чтобы использовать матрицу. Вместо добавления значения `t` к координатам, мы собираемся применить к ним матрицу, умножив ее. Это применяет преобразование, описываемое нашей матрицей, к координатам вершины.

```rust
let vertex_shader_src = r#"
    #version 140

    in vec2 position;

    uniform mat4 matrix;

    void main() {
        gl_Position = matrix * vec4(position, 0.0, 1.0);
    }
"#;
```

Обратите внимание, что важно писать `matrix * vertex`, а не `vertex * matrix`. Матричные операции дают разные результаты в зависимости от порядка.

Нам также нужно передать матрицу при вызове функции `draw`:

```rust
let uniforms = uniform! {
    matrix: [
        [1.0, 0.0, 0.0, 0.0],
        [0.0, 1.0, 0.0, 0.0],
        [0.0, 0.0, 1.0, 0.0],
        [ t , 0.0, 0.0, 1.0f32],
    ]
};

target.draw(&vertex_buffer, &indices, &program, &uniforms,
            &Default::default()).unwrap();
```

Вы должны увидеть то же самое, что и раньше, но то, что у нас сейчас, гораздо более гибкое решение. Например, если вместо этого мы хотим повернуть треугольник, мы можем вместо этого попробовать эту матрицу:

```rust
let uniforms = uniform! {
    matrix: [
        [ t.cos(), t.sin(), 0.0, 0.0],
        [-t.sin(), t.cos(), 0.0, 0.0],
        [0.0, 0.0, 1.0, 0.0],
        [0.0, 0.0, 0.0, 1.0f32],
    ]
};
```

**[Вы можете найти весь исходный код здесь](https://github.com/glium/glium/blob/master/examples/tutorial-04.rs).**
