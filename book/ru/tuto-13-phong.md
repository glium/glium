# Blinn-Phong затенение

Наша текущая модель освещения немного примитивна. Мы собираемся изменить его, чтобы использовать то, что называется *Blinn-Phong затенение*.

Эта модель до сих пор очень часто используется в коммерческих играх и только недавно была заменена физическим рендерингом.

## Зеркальное отражение

Так что именно не так с нашим текущим освещением?

Когда свет попадает на объект, лучи света разделяются на две части:

 - Некоторые лучи будут отражены во всех направлениях. Это диффузное отражение.
 - Некоторые лучи будут отражаться перпендикулярно нормали поверхности, как если бы объект был зеркалом. Это зеркальное отражение.

Когда вы берете отдельный фрагмент, цвет фрагмента представляет собой сочетание его диффузного и зеркального отражений. Наш текущий шейдер учитывает только диффузное отражение, но не зеркальное отражение.

Так как же выглядит расчет?

```glsl
#version 140

in vec3 v_normal;
in vec3 v_position;

out vec4 color;

uniform vec3 u_light;

const vec3 ambient_color = vec3(0.2, 0.0, 0.0);
const vec3 diffuse_color = vec3(0.6, 0.0, 0.0);
const vec3 specular_color = vec3(1.0, 1.0, 1.0);

void main() {
    float diffuse = max(dot(normalize(v_normal), normalize(u_light)), 0.0);

    vec3 camera_dir = normalize(-v_position);
    vec3 half_direction = normalize(normalize(u_light) + camera_dir);
    float specular = pow(max(dot(half_direction, normalize(v_normal)), 0.0), 16.0);

    color = vec4(ambient_color + diffuse * diffuse_color + specular * specular_color, 1.0);
}
```

Первая строка основной функции более или менее совпадает с тем, что было в предыдущем шейдере, за исключением того, что на этот раз мы фиксируем значение, чтобы оно не могло быть отрицательным. В этом раньше не было необходимости, потому что мы использовали функцию `mix` (которая автоматически обрабатывает это), но теперь мы должны это сделать.

Затем мы вычисляем `camera_dir`, который является направлением камеры относительно объекта. Поскольку камера всегда находится в `(0, 0, 0)`, это вычисляется просто путем взятия противоположности позиции вектора.

![Схема того, что происходит](../tuto-13-specular.png)

После этого мы вычисляем `half_direction`, которое является направлением камеры относительно света, если камера и источник света находились на расстоянии одной единицы от объекта. Затем мы вычисляем косинус угла между `half_direction` и` v_normal` с помощью `dot (half_direction, normalize (v_normal))`.

Если `half_direction` перпендикулярно нормали, это означает, что световые лучи, исходящие от света, отражаются прямо в камеру. Результат расчета будет `1.0`. Затем мы гарантируем, что это значение является положительным, и возводим его в степень 16. Это означает, что значения, такие как `0.98`, будут оставаться высокими, но значения, такие как `0.8`, почти упадут до 0. Роль этой силы состоит в том, чтобы отмечать границу между высокими значениями и низкими значениями. Это наш зеркальный коэффициент.

Последний шаг - это сложить все вместе: окружающее освещение (то есть освещение, которое присутствует даже при отсутствии источника света) + рассеянное освещение + зеркальное освещение. Обратите внимание, что в некоторых случаях значение может превышать `1.0`, но OpenGL автоматически ограничивает его до `1.0`.

Не забудьте изменить наш вершинный шейдер так, чтобы он передавал дополнительный атрибут `v_position`, добавив в конце следующую строку:

```glsl
v_position = gl_Position.xyz / gl_Position.w;
```

И вот результат:

![Результат](../tuto-13-result.png) ![Результат](../tuto-13-result2.png)

Большие белые пятна - зеркальное отражение.

**[Вы можете найти весь исходный код здесь](https://github.com/glium/glium/blob/master/examples/tutorial-13.rs).**
