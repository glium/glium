# Затенение по Гуро

Давайте продолжим работать с чайником из предыдущего раздела:

![Чайник](../tuto-07-correct.png)

Очевидно, что с этим изображением что-то не так: мы не видим никаких кривых чайника, кроме как на его границах. Это не потому, что чайник красный, а потому, что там нет освещения.

Освещение - это очень сложная тема, и существует множество различных техник, но для начала мы будем использовать *затенение по Гуро*, который очень прост.

## Теория

Идея затенения Гуро заключается в том, что если направление света перпендикулярно поверхности объекта, то эта поверхность должна быть яркой. Если направление света параллельно поверхности, то поверхность должна быть темной.

![Теория](../tuto-08-theory.png)

Мы собираемся сделать этот расчет по одному на фрагмент, в нашем фрагментном шейдере. Яркость каждого пикселя должна быть равна `sin(angle(surface, light))`. Если свет перпендикулярен, угол равен `pi / 2` радиан, а яркость равна `1`. Если источник света параллельный, угол равен `0`, а яркость равна `0`.

Вопрос в том, откуда мы знаем угол между поверхностью и светом. Это то место где нормали вступают в игру.

Как мы видели в предыдущем разделе, вектор нормали - это вектор, перпендикулярный поверхности в данной вершине. Нормаль вершины может быть вычислена только путем знания соседних вершин, поэтому нормали обычно рассчитываются при экспорте модели из программного обеспечения для трехмерного моделирования.

![Нормали](../tuto-08-normals.png)

Так как нормаль перпендикулярна поверхности объекта, мы должны скорректировать расчет. Если свет * параллелен * нормальному, то поверхность должна быть яркой. И если свет * перпендикулярен * к нормали, то поверхность должна быть темной. Наша формула такова:
`brightness = cos(angle(normal, light));`

## На практике

Основная часть расчета будет выполнена в фрагментном шейдере. Однако сначала нам нужно изменить вершинный шейдер, чтобы передать данные нормали во фрагментный шейдер. В дополнение к этому нам нужно указать более новую версию GLSL, поскольку v140 не поддерживает функции, которые мы собираемся использовать. Для работы вершинного шейдера нам нужен как минимум GLSL v150.

```glsl
#version 150      // обновлено

in vec3 position;
in vec3 normal;

out vec3 v_normal;      // новое

uniform mat4 matrix;

void main() {
    v_normal = transpose(inverse(mat3(matrix))) * normal;       // новое
    gl_Position = matrix * vec4(position, 1.0);
}
```

Нам также нужно умножить нормаль на матрицу, но преобразования немного отличаются, а вычисления немного странные. Поскольку я не вдавался в подробности о том, как работают матрицы, я не буду вдаваться в подробности о том, почему вы должны использовать транспонирование инверсии.

Если вы помните раздел о цветах, атрибуты, которые мы передаем от вершинного шейдера к фрагментному шейдеру, интерполируются на каждый фрагмент. Это означает, что каждый фрагмент будет отличаться от нормального от соседних фрагментов, и, следовательно, другого цвета.

Теперь давайте посмотрим на наш фрагментный шейдер:

```glsl
#version 140

in vec3 v_normal;
out vec4 color;
uniform vec3 u_light;

void main() {
    float brightness = dot(normalize(v_normal), normalize(u_light));
    vec3 dark_color = vec3(0.6, 0.0, 0.0);
    vec3 regular_color = vec3(1.0, 0.0, 0.0);
    color = vec4(mix(dark_color, regular_color, brightness), 1.0);
}
```

Чтобы вычислить яркость фрагмента, мы рассчитываем [dot product](https://en.wikipedia.org/wiki/Dot_product) для `v_normal` и `u_light` после нормализации. Это очень эффективный метод, который напрямую возвращает косинус угла между двумя векторами и требует только трех умножений и трех сложений.

Затем мы объявляем два цвета: цвет, когда поверхность полностью темная, и цвет, когда поверхность полностью яркая. В реальной жизни это не потому, что объект не подвергается прямому воздействию источника света, что он черный. Даже неэкспонированные поверхности получают немного света от косвенных источников. Поэтому темный цвет - это не черный, а промежуточный уровень красного.

Затем функция `mix` интерполирует темные и яркие цвета в зависимости от яркости.

Не забудьте передать новый универсальный параметр `u_light` при рисовании:

```rust
// направление света
let light = [-1.0, 0.4, 0.9f32];

target.draw((&positions, &normals), &indices, &program,
            &uniform! { matrix: matrix, u_light: light },
            &Default::default()).unwrap();
```

И вот результат:

![Результат](../tuto-08-result.png)

Теперь, когда у нас есть яркость, мы можем видеть, что есть больше вещей, которые не соответствуют нашему рендерингу, это будет описано в следующих разделах!

**[Вы можете найти весь исходный код здесь](https://github.com/glium/glium/blob/master/examples/tutorial-08.rs).**
