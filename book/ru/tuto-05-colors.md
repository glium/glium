# Атрибуты

В нашем программном конвейере цвет каждого пикселя внутри треугольника соответствует выводу нашего фрагментного шейдера. Поскольку наш фрагментный шейдер возвращает `(1.0, 0.0, 0.0, 1.0)`, каждый пиксель является непрозрачным красным (четыре значения соответствуют: красный, зеленый, синий, альфа/непрозрачность).

Чтобы вывести правильный цвет, нам нужна информация о пикселе, который мы пытаемся нарисовать. К счастью, можно передавать информацию между вершиной и фрагментным шейдером.

Для этого мы просто добавляем переменную `out` в вершинный шейдер...

```glsl
#version 140

in vec2 position;
out vec2 my_attr;      // наш новый атрибут

uniform mat4 matrix;

void main() {
    my_attr = position;     // нам нужно установить значение каждой переменной `out`.
    gl_Position = matrix * vec4(position, 0.0, 1.0);
}
```

...и переменная `in` с тем же именем и типом во фрагментном шейдере.

```glsl
#version 140

in vec2 my_attr;
out vec4 color;

void main() {
    color = vec4(my_attr, 0.0, 1.0);   // мы строим vec4 из vec2 и двух чисел с плавающей запятой
}
```

Давай посмотрим что происходит. Наш вершинный шейдер вызывается три раза, по одному на каждую вершину. Каждая вершина возвращает свое значение для my_attr. Затем OpenGL определяет, какие пиксели находятся внутри треугольника во время фазы растеризации, и вызывает фрагментный шейдер один раз для каждого из этих пикселей. Значение `my_attr`, которое передается для каждого пикселя, является **интерполяцией этого значения в зависимости от положения пикселя**.

Например, пиксели, которые находятся рядом с вершиной, получат значение `my_attr`, которое равно или очень близко к значению `my_attr`, которое вершинный шейдер возвратил для этой вершины. Пиксель, который находится на середине ребра между двумя вершинами, получит среднее значение двух значений my_attr, возвращаемых вершинным шейдером для этих двух вершин. Пиксели, которые являются серединой треугольника, получат среднее значение трех вершин.

*Примечание: это потому, что переменные по умолчанию имеют атрибут `smooth`, который вам нужен в большинстве случаев. Также можно указать атрибут `flat`.*

В приведенном выше примере значение `my_attr`, возвращаемое вершинным шейдером, соответствует положению вершины. Поэтому значение `my_attr`, которое получит фрагментный шейдер, соответствует позиции обрабатываемого пикселя. Для демонстрации мы превращаем эту позицию в красный и зеленый компоненты нашего цвета.

И результат должен выглядеть так:

![Результат](../tuto-05-linear.png)

**[Вы можете найти весь исходный код здесь](https://github.com/glium/glium/blob/master/examples/tutorial-05.rs).**
