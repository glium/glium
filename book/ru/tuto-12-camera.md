# Камера и краткое изложение этапов обработки вершин

С текущим кодом вы можете перемещать, поворачивать или изменять масштаб чайника, изменяя содержимое `матрицы`.

Но в реальной игре вам нужно организовать вещи по-другому. Объекты находятся внутри сцены и просматриваются с камеры. Вы не можете просто изменить характеристику каждого объекта, думая о том, как он будет отображаться на экране. Вам нужна лучшая организация.

В реальном игровом движке вычисление положения вершины (от атрибута `position` до `gl_Position`) обычно выполняется в три этапа:

 - Превращение координат относительно центра модели (атрибут `положение`) в координаты относительно сцены (где координаты `(0, 0)` являются общими для всех объектов сцены). Это использует положение объекта, вращение и масштаб.

 - Превращение координат относительно сцены в координаты относительно положения и поворота камеры. Здесь используется так называемая *матрица вида* (мы увидим это ниже).

 - Превращение координат относительно камеры в координаты относительно экрана с использованием матрицы перспективы.

*Примечание*: это становится немного сложнее при работе с анимированными моделями.

Следовательно, у вас есть три матрицы:

 - Матрица *модели*, построенная с использованием положения объекта, поворота и масштаба в сцене.
 - Матрица *Вида*, построенная с учетом положения и поворота камеры на сцене.
 - Матрица *перспективы*, построенная с учетом поля зрения и соотношения сторон экрана.

Первые две матрицы иногда объединяются в одну матрицу *modelview* перед загрузкой в ваши шейдеры. Но для простоты мы будем использовать две матрицы.

## Матрица вида

Так же, как матрица перспективы, вот матрица вида:

```rust
fn view_matrix(position: &[f32; 3], direction: &[f32; 3], up: &[f32; 3]) -> [[f32; 4]; 4] {
    let f = {
        let f = direction;
        let len = f[0] * f[0] + f[1] * f[1] + f[2] * f[2];
        let len = len.sqrt();
        [f[0] / len, f[1] / len, f[2] / len]
    };

    let s = [up[1] * f[2] - up[2] * f[1],
             up[2] * f[0] - up[0] * f[2],
             up[0] * f[1] - up[1] * f[0]];

    let s_norm = {
        let len = s[0] * s[0] + s[1] * s[1] + s[2] * s[2];
        let len = len.sqrt();
        [s[0] / len, s[1] / len, s[2] / len]
    };

    let u = [f[1] * s_norm[2] - f[2] * s_norm[1],
             f[2] * s_norm[0] - f[0] * s_norm[2],
             f[0] * s_norm[1] - f[1] * s_norm[0]];

    let p = [-position[0] * s_norm[0] - position[1] * s_norm[1] - position[2] * s_norm[2],
             -position[0] * u[0] - position[1] * u[1] - position[2] * u[2],
             -position[0] * f[0] - position[1] * f[1] - position[2] * f[2]];

    [
        [s_norm[0], u[0], f[0], 0.0],
        [s_norm[1], u[1], f[1], 0.0],
        [s_norm[2], u[2], f[2], 0.0],
        [p[0], p[1], p[2], 1.0],
    ]
}
```

Функция принимает три аргумента:

 - `position` - позиция камеры на сцене.
 - `direction` - куда направлена камера в координатах сцены.
 - `up` - вектор, представляющий направление в координатах сцены в верхней части экрана.

Нам нужно еще раз реорганизовать наш вершинный шейдер:

```glsl
#version 140

in vec3 position;
in vec3 normal;

out vec3 v_normal;

uniform mat4 perspective;
uniform mat4 view;
uniform mat4 model;

void main() {
    mat4 modelview = view * model;
    v_normal = transpose(inverse(mat3(modelview))) * normal;
    gl_Position = perspective * modelview * vec4(position, 1.0);
}
```

Помните, что порядок умножений является обратным порядку, в котором должны применяться преобразования. Матрица, которую нужно применить первой, является ближайшей к входу.

Как обычно, нам нужно пройти новую униформу:

```rust
let view = view_matrix(&[2.0, -1.0, 1.0], &[-2.0, 1.0, 1.0], &[0.0, 1.0, 0.0]);

target.draw((&positions, &normals), &indices, &program,
            &uniform! { model: model, view: view, perspective: perspective, u_light: light },
            &params).unwrap();
```

Мы используем фиксированные координаты для примера. Камеру от первого лица создать не так-то просто, для нее требуется много кода, который был бы вне области видимости.

И вот результат:

![Результат](../tuto-12-result.png)

**[Вы можете найти весь исходный код здесь](https://github.com/glium/glium/blob/master/examples/tutorial-12.rs).**
