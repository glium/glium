# Анимирование нашего треугольника

Теперь, когда у нас есть треугольник, мы попробуем его оживить. Помните, что OpenGL похож на программное обеспечение для рисования. Если мы хотим внести изменения на экране, мы должны нарисовать существующий контент, чтобы заменить то, что уже есть. К счастью, у нас уже есть `цикл`, который непрерывно рисует в окне, поэтому наши изменения почти мгновенно отразятся на окне.

# Наивный подход

Нашим первым подходом будет создание переменной с именем `t`, которая представляет шаг в анимации. Мы обновляем значение `t` в каждом цикле и добавляем его к координатам нашего треугольника в каждом кадре:

```rust
let mut t: f32 = -0.5;
let mut closed = false;
while !closed {
    // мы обновляем `t`
    t += 0.0002;
    if t > 0.5 {
        t = -0.5;
    }

    // мы создаем форму и добавляем `t` к каждой координате x
    let vertex1 = Vertex { position: [-0.5 + t, -0.5] };
    let vertex2 = Vertex { position: [ 0.0 + t,  0.5] };
    let vertex3 = Vertex { position: [ 0.5 + t, -0.25] };
    let shape = vec![vertex1, vertex2, vertex3];
    let vertex_buffer = glium::VertexBuffer::new(&display, &shape).unwrap();

    // рисуем
    let mut target = display.draw();
    target.clear_color(0.0, 0.0, 1.0, 1.0);
    target.draw(&vertex_buffer, &indices, &program, &glium::uniforms::EmptyUniforms,
                &Default::default()).unwrap();
    target.finish().unwrap();

    events_loop.poll_events(|event| {
        match event {
            glutin::Event::WindowEvent { event, .. } => match event {
                glutin::WindowEvent::CloseRequested => closed = true,
                _ => ()
            },
            _ => (),
        }
    });
}
```

Если вы запустите этот код, вы увидите, что ваш треугольник идет слева направо от экрана, а затем снова прыгает влево!

Этот метод является примерно тем, чем занимались разработчики игр в 1990-х годах. Это прекрасно работает, когда у вас маленькие фигуры (например, один треугольник), но крайне неэффективно, когда вы манипулируете моделями с тысячами полигонов. Для этого есть две причины:

 - Графический процессор будет тратить много времени на вычисление координат каждый раз, когда вы рисуете (с одной операцией для каждой вершины для каждой модели, в конце вы достигаете сотен тысяч операций).

 - Требуется некоторое время, чтобы загрузить нашу форму из оперативной памяти в видеопамять. Это время полностью потрачено впустую, поскольку GPU должен ждать, пока передача не закончится, чтобы начать свою работу.

# Униформы

Вы помните вершинные шейдеры? Наш вершинный шейдер принимает в качестве входных данных атрибуты каждой вершины и выводит ее положение в окне. Вместо того, чтобы делать сложение в нашей программе и загружать результат, мы попросим GPU выполнить эту операцию.

Давайте вернем нашу программу к тому, что было в конце первого урока, но оставим `t`:

```rust
let vertex1 = Vertex { position: [-0.5, -0.5] };
let vertex2 = Vertex { position: [ 0.0,  0.5] };
let vertex3 = Vertex { position: [ 0.5, -0.25] };
let shape = vec![vertex1, vertex2, vertex3];

let vertex_buffer = glium::VertexBuffer::new(&display, &shape).unwrap();

let mut t: f32 = -0.5;
let mut closed = false;
while !closed {
    // мы обновляем `t`
    t += 0.0002;
    if t > 0.5 {
        t = -0.5;
    }

    // рисуем
    let mut target = display.draw();
    target.clear_color(0.0, 0.0, 1.0, 1.0);
    target.draw(&vertex_buffer, &indices, &program, &glium::uniforms::EmptyUniforms,
                &Default::default()).unwrap();
    target.finish().unwrap();

    events_loop.poll_events(|event| {
        match event {
            glutin::Event::WindowEvent { event, .. } => match event {
                glutin::WindowEvent::CloseRequested => closed = true,
                _ => ()
            },
            _ => (),
        }
    });
}
```

И вместо этого мы собираемся сделать небольшое изменение в нашем вершинном шейдере:

```rust
let vertex_shader_src = r#"
    #version 140

    in vec2 position;

    uniform float t;

    void main() {
        vec2 pos = position;
        pos.x += t;
        gl_Position = vec4(pos, 0.0, 1.0);
    }
"#;
```

Вы можете заметить, что это именно та операция, которую мы выполняли выше, за исключением того, что на этот раз она выполняется на стороне графического процессора. Мы добавили переменную `t` в наш шейдер, которая объявлена как **uniform**. Униформа - это глобальная переменная, значение которой устанавливается, когда мы рисуем, передавая ее значение в функцию `draw`. Самый простой способ сделать это - использовать макрос `uniform!`:

```rust
target.draw(&vertex_buffer, &indices, &program, &uniform! { t: t },
            &Default::default()).unwrap();
```

Использование uniform переменных решает две наши проблемы выше. Графическому процессору не нужно выполнять никаких вычислений, и все, что он загрузил, это значение `t` (одиночное число с плавающей запятой) вместо всей фигуры.
