# Синхронизация

Почти все реализации OpenGL сегодня аппаратно ускорены. Это означает, что когда вы выполняете команды OpenGL, фактически ваша видеокарта выполняет тяжелую работу вместо вашего процессора.

Чтобы улучшить производительность, вызов функции OpenGL не ожидает завершения операции. Вместо этого он просто отправляет команду и немедленно возвращается. В хорошем приложении процессор добавляет команды в очередь, а графический процессор читает их и обрабатывает их параллельно.

*Примечание: если графический процессор обрабатывает команды быстрее, чем процессор отправляет их, мы говорим, что приложение привязано к процессору. В другом случае приложение привязано к графическому процессору. ААА видеоигры почти всегда привязаны к GPU.*

Но есть проблема: в некоторых ситуациях нет другого выбора, кроме как дождаться окончания выполнения команд. Например, если вы читаете содержимое только что нарисованной текстуры, технически нет другого выбора, кроме как дождаться окончания рендеринга перед чтением. Это называется **синхронизация**, потому что процессор и графический процессор должны синхронизироваться вместо того, чтобы выполнять вещи параллельно.

Ваша задача как программиста OpenGL - любой ценой избежать операций, вызывающих синхронизацию.

## Чтение из текстуры или из кадрового буфера

Чтобы прочитать текстуру или кадровый буфер без синхронизации, мы должны использовать **пиксельный буфер**. Вместо непосредственного чтения текстуры мы просим графический процессор скопировать ее содержимое в буфер, и мы читаем буфер позже или в следующем кадре.

Как и любая другая операция, копирование из текстуры в пиксельный буфер является обычной командой, которая будет выполняться графическим процессором. Если мы будем ждать достаточно времени, буфер больше не будет использоваться, и мы можем прочитать его без ожидания.

## Об операциях только для записи

Одной из распространенных операций, которые часто выполняются в графическом программировании, является потоковая передача данных в графический процессор. Другими словами, вы отправляете данные в буфер или текстуру непосредственно перед их использованием. Это делается, например, при рендеринге частиц (которые много двигаются) или при декодировании видео.

Поскольку создание буфера или текстуры может быть дорогостоящим, предпочтительно всегда использовать один и тот же буфер или текстуру и записывать в него данные.

Здесь есть две возможности:

 - Вы переписываете содержимое всего буфера или текстуры.
 - Вы пишете только некоторые части буфера или текстуры.

Эти две ситуации очень разные. Если вы переписываете весь буфер или текстуру, то реализация OpenGL обычно достаточно умна, чтобы фактически выделить новый буфер или текстуру и поместить ваши данные в нее вместо повторного использования той же памяти. Это сделано абсолютно прозрачным способом.

Вместо этого, если вы пишете только некоторые части буфера или текстуры, то реализация не может этого сделать. Это где **аннулирование** буфера или текстуры вступает в игру. Вызывая `.invalidate ()`, вы говорите реализации OpenGL, что вам все равно, что уже находится в буфере. Это позволяет использовать ту же оптимизацию, что и при перезаписи всего буфера или текстуры.
