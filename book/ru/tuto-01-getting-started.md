# Создание проекта

Чтобы начать этот урок, мы создадим новый проект с нуля. Несмотря на то, что перед началом работы настоятельно рекомендуется ознакомиться с Rust and Cargo, некоторые небольшие напоминания будут присутсвовать. Давайте начнем с создания нового проекта:

```sh
cargo new --bin my_project
cd my_project
```

Каталог, который вы только что создали, должен содержать файл `Cargo.toml`, который содержит метаданные нашего проекта, а так же файл `src/main.rs`, который содержит исходный код Rust. Если у вас есть файл `src/lib.rs`, это означает, что вы забыли добавить флаг `--bin`. В этом случае просто переименуйте файл.

Чтобы использовать библиотеку glium, нам нужно добавить её в качестве зависимости в наш файл `Cargo.toml`:

```toml
[dependencies]
glium = "*"
```

Перед использованием, нам также нужно импортировать эту библиотеку в наш файл `src/main.rs` как указано здесь:

```rust
#[macro_use]
extern crate glium;

fn main() {
}
```

Теперь пришло время начинать заполнять функцию `main`!

# Создание окна

Первым шагом при создании графического приложения является создание окна. Если вы когда-либо работали с OpenGL раньше, вы знаете, как трудно это сделать правильно. Как создание окон, так и создание контекста зависят от платформы, а иногда они бывают странными и утомительными. К счастью, эту проблему решает библиотека **glutin**, которая уже встроена в **glium**.

Инициализация окна OpenGL с помощью glutin может быть выполнена с помощью следующих шагов:

1. Создание `EventsLoop` для обработки событий окна и устройства.
2. Указание параметров окна, используя `glium::glutin::WindowBuilder::new()`. Эти     специфичные для окна атрибуты не имеют ничего общего с OpenGL.
3. Указание параметров контекста, используя `glium::glutin::ContextBuilder::new()`. Здесь мы указываем специфичные для OpenGL атрибуты, такие как multisampling        или vsync.
4. Создание окна OpenGL (в glium это `Display`): `glium::Display::new(window, context, &events_loop).unwrap()`. Это создает отображение окна, используя заданные атрибуты и контекст, и регистрирует окно с заданным events_loop.

```rust
fn main() {
    use glium::glutin;

    let mut events_loop = glutin::EventsLoop::new();
    let window = glutin::WindowBuilder::new();
    let context = glutin::ContextBuilder::new();
    let display = glium::Display::new(window, context, &events_loop).unwrap();
}
```

Но есть проблема: как только окно было создано, наша основная функция завершается, и деструктор display закрывает окно. Чтобы предотвратить это, нам нужно создать цикл, который предотвратит закрытие окна, пока не будет вызвано событие `CloseRequested`

```rust
let mut closed = false;
while !closed {
    // Обработка событий, которые генерируются приложением
    events_loop.poll_events(|ev| {
        match ev {
            glutin::Event::WindowEvent { event, .. } => match event {
                glutin::WindowEvent::CloseRequested => closed = true,
                _ => (),
            },
            _ => (),
        }
    });
}
```

Прямо сейчас этот код будет нагружать ваш процессор на 100%, но это будет делать пока. В реальном приложении вы должны либо использовать вертикальную синхронизацию, либо переводить поток в режим сна на несколько миллисекунд в конце цикла, но это более сложная тема.

Теперь вы можете выполнить `cargo run`. Через несколько минут, в течение которых Cargo загружает и компилирует glium и его зависимости, вы увидите маленькое симпатичное окно.

### Очистка цвета

Содержание окна, однако, не очень привлекательно. В зависимости от вашей системы он может выглядеть черным, отображать случайное изображение или просто немного снега. Предполагается, что мы будем рисовать в окне, чтобы система не удосужилась инициализировать свой цвет определенным значением.

Glium и OpenGL API работают аналогично программам для рисования, таким как Windows Paint или GIMP. Мы начинаем с пустого изображения, затем рисуем на нем объект, затем другой объект, затем другой объект и так далее. Пока не будем удовлетворены результатом. Но в отличие от программного обеспечения для рисования, вы не хотите, чтобы ваши пользователи видели промежуточные шаги. Вы хотите показать пользователю только конечный результат.

Чтобы справиться с этим, OpenGL использует то, что называется *двойной буферизацией* (*double buffering*). Вместо того, чтобы рисовать прямо в окне, мы рисуем изображение, хранящееся в памяти. Как только мы закончили рисовать, это изображение копируется в окно.
Это представлено в glium объектом `Frame`. Когда вы хотите начать рисовать что-то в своем окне, вы должны сначала вызвать `display.draw()`, чтобы создать `Frame`:

```rust
let mut target = display.draw();
```

Затем мы можем использовать этот `target` в качестве поверхности для рисования. Одной из операций, которые предоставляют OpenGL и glium, является заполнение поверхности заданным цветом. Это то, что мы собираемся сделать в этом разделе.

```rust
target.clear_color(0.0, 0.0, 1.0, 1.0);
```

Обратите внимание, что для использования этой функции нам нужно сначала импортировать trait `Surface`:

```rust
use glium::Surface;
```

Четыре значения, которые мы передаем в `clear_color`, представляют четыре компонента нашего цвета: красный, зеленый, синий и альфа. Допустимы только значения между `0.0` и `1.0`. Здесь мы рисуем непрозрачный синий цвет.

Как я объяснил выше, пользователь не сразу видит синий цвет на экране. На этом этапе, если бы мы были в реальном приложении, мы бы, скорее всего, нарисовали наших персонажей, их оружие, землю, небо и так далее. Но в этом уроке мы просто остановимся здесь:

```rust
target.finish().unwrap();
```

Этот вызов метода `finish()` означает, что мы закончили рисовать. Он уничтожает объект `Frame` и копирует наше фоновое изображение в окно. Наше окно теперь заполнено синим цветом.

Вот наша полная функция `main` после этого шага:

```rust
fn main() {
    use glium::{glutin, Surface};

    let mut events_loop = glium::glutin::EventsLoop::new();
    let window = glium::glutin::WindowBuilder::new();
    let context = glium::glutin::ContextBuilder::new();
    let display = glium::Display::new(window, context, &events_loop).unwrap();

    let mut closed = false;
    while !closed {
        let mut target = display.draw();
        target.clear_color(0.0, 0.0, 1.0, 1.0);
        target.finish().unwrap();

        events_loop.poll_events(|ev| {
            match ev {
                glutin::Event::WindowEvent { event, .. } => match event {
                    glutin::WindowEvent::CloseRequested => closed = true,
                    _ => (),
                },
                _ => (),
            }
        });
    }
}
```
