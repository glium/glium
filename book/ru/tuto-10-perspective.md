# Перспектива

Матрица, которую мы передаем шейдеру при рисовании нашего чайника, содержит положение, вращение и масштаб нашей модели чайника. Например, третья строка четвертого столбца содержит координату z объекта. Если мы изменим его на `0.5`, это увеличит положение z у объекта на `0.5`.

```rust
let matrix = [
    [0.01, 0.0, 0.0, 0.0],
    [0.0, 0.01, 0.0, 0.0],
    [0.0, 0.0, 0.01, 0.0],
    [0.0, 0.0, 0.5, 1.0f32]
];
```

*Примечание: это действительно третий ряд четвертого столбца. Матрицы хранятся в основном порядке столбцов, то есть мы сохраняем первый столбец, затем второй столбец, затем третий столбец, затем четвертый столбец.*

... за исключением того, что нет абсолютно никаких изменений, и наша модель все еще находится в том же положении. Это работает, однако, если вы измените координаты X или Y.

Причина, по которой изменение глубины объекта не имеет никакого эффекта, заключается в том, что наша сцена не имеет никакой перспективы! Глубина используется только вместе с буфером глубины (см. Предыдущий раздел) и все. В реальной жизни чем дальше объект от глаза, тем меньше он должен выглядеть.

## Коррекция перспективы

Чтобы объекты выглядели меньше при удалении будем использовать просто решение: разделим координаты x и y на координату z (умноженную на константу). Поскольку координата `(0, 0)` находится в центре экрана, объекты, которые находятся далеко, будут выглядеть так, как будто они находятся ближе к центру экрана, который является [точкой схода](https://en.wikipedia.org/wiki/Vanishing_point).

Но при простых умножениях матриц невозможно разделить x и y на z. Здесь вступает в действие четвертая координата `gl_Position`! Вместо того, чтобы делить x и y, мы собираемся поместить фактор в координату `w`. После выполнения вершинного шейдера первые три координаты будут разделены на `w`.

Не волнуйтесь, если это кажется запутанным. Самая важная вещь, которую нужно помнить, состоит в том, что эта четвертая координата существует в качестве математического трюка для коррекции перспективы.

## Соотношение сторон

Еще одна вещь, которую вы, возможно, заметили, это то, что наш чайник растянется, чтобы заполнить все окно. Это нормально, так как координаты от `-1` до `1` соответствуют границам окна.

Однако в видеоиграх сцена не растягивается. Вместо этого, если вы измените размер окна, вы заметите, что увидите большую или меньшую часть сцены.

Чтобы это исправить, нам нужно умножить координату x на соотношение высоты и ширины экрана. Мы сжимаем объекты нашей сцены таким образом, что когда они растягиваются, чтобы соответствовать размерам окна, они возвращаются к своему первоначальному соотношению.

## Представляем матрицу перспективы

Причина, по которой эти две проблемы находятся в одном учебнике, заключается в том, что графические движки обычно решают обе задачи с помощью одной матрицы: **матрицы перспективы**.

```rust
let perspective = {
    let (width, height) = target.get_dimensions();
    let aspect_ratio = height as f32 / width as f32;

    let fov: f32 = 3.141592 / 3.0;
    let zfar = 1024.0;
    let znear = 0.1;

    let f = 1.0 / (fov / 2.0).tan();

    [
        [f *   aspect_ratio   ,    0.0,              0.0              ,   0.0],
        [         0.0         ,     f ,              0.0              ,   0.0],
        [         0.0         ,    0.0,  (zfar+znear)/(zfar-znear)    ,   1.0],
        [         0.0         ,    0.0, -(2.0*zfar*znear)/(zfar-znear),   0.0],
    ]
};
```

*Примечание: на самом деле есть два разных соглашения: левша и правша. Для этого урока мы используем левшу, потому что он не инвертирует координату z.*

При построении матрицы используются четыре параметра:

 - Соотношение сторон: `высота / ширина`.
 - *Поле зрения* (или *fov*), которое представляет собой угол камеры. Если вы играли в шутеры от первого лица, вы, вероятно, знаете об этом. Здесь нет "правильного" значения, так как оно зависит от предпочтений пользователя и настроек. Если вы играете на компьютере, вам обычно требуется более высокий fov, чем если бы вы играли по телевизору.
 - `znear` и` zfar` - это минимальные и максимальные значения глубины, которые находятся в поле зрения игрока. Эти значения не влияют на визуальный аспект сцены, но они могут быть важны для точности буфера глубины.

Не волнуйтесь, если вы точно не понимаете, что происходит. Эта матрица необходима, чтобы сделать сцену реалистичной.

Поскольку мы не хотим умножать наши нормали на нашу матрицу перспективы, мы будем использовать две разные матрицы: регулярную матрицу, содержащую регулярные преобразования нашего объекта, и матрицу перспективы.

```glsl
#version 140

in vec3 position;
in vec3 normal;

out vec3 v_normal;

uniform mat4 perspective;       // новое
uniform mat4 matrix;

void main() {
    v_normal = transpose(inverse(mat3(matrix))) * normal;
    gl_Position = perspective * matrix * vec4(position, 1.0);       // новое
}
```

Не забудьте сдать дополнительную униформу:

```rust
target.draw((&positions, &normals), &indices, &program,
            &uniform! { matrix: matrix, perspective: perspective, u_light: light },
            &params).unwrap();
```

Сцена теперь имеет правильный расчет перспективы! Теперь мы можем перемещать чайник между любыми значениями между `znear` и `zfar`. Например `2.0`:

```rust
let matrix = [
    [0.01, 0.0, 0.0, 0.0],
    [0.0, 0.01, 0.0, 0.0],
    [0.0, 0.0, 0.01, 0.0],
    [0.0, 0.0, 2.0, 1.0f32]
];
```

И вот результат:

![Рузультат](../tuto-10-result.png)

Также обратите внимание, что объект сохраняет свой обычный вид даже при изменении размера и больше не растягивается.

Если вы сравните это с предыдущим снимком экрана, вы также можете увидеть, как чайник теперь выглядит намного лучше.

**[Вы можете найти весь исходный код здесь](https://github.com/glium/glium/blob/master/examples/tutorial-10.rs).**
