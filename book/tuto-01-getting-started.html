<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Opening a window - Glium Tutorials</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="README.html">Intro</a></li><li><a href="tuto-01-getting-started.html" class="active"><strong>1.</strong> Opening a window</a></li><li><a href="tuto-02-triangle.html"><strong>2.</strong> Drawing a triangle</a></li><li><a href="tuto-03-animated-triangle.html"><strong>3.</strong> Uniforms</a></li><li><a href="tuto-04-matrices.html"><strong>4.</strong> Matrices</a></li><li><a href="tuto-05-colors.html"><strong>5.</strong> Adding colors</a></li><li><a href="tuto-06-texture.html"><strong>6.</strong> Adding a texture</a></li><li><a href="tuto-07-shape.html"><strong>7.</strong> A more complex shape</a></li><li><a href="tuto-08-gouraud.html"><strong>8.</strong> Gouraud shading</a></li><li><a href="tuto-09-depth.html"><strong>9.</strong> Depth testing</a></li><li><a href="tuto-10-perspective.html"><strong>10.</strong> Adjusting the perspective</a></li><li><a href="tuto-11-backface-culling.html"><strong>11.</strong> Backface culling</a></li><li><a href="tuto-12-camera.html"><strong>12.</strong> The camera and summary of the vertex processing stages</a></li><li><a href="tuto-13-phong.html"><strong>13.</strong> Blinn-phong shading</a></li><li><a href="tuto-14-wall.html"><strong>14.</strong> Normal mapping</a></li><li><strong>15.</strong> Parallax mapping</li><li><strong>16.</strong> Deferred shading</li><li><strong>17.</strong> Shadow mapping</li><li><strong>18.</strong> Antialiasing</li><li><strong>19.</strong> Drawing lots of objects with instancing</li><li><a href="perf-intro.html"><strong>20.</strong> Performance</a></li><li><a href="perf-sync.html"><strong>21.</strong> Synchronization</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Glium Tutorials</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="tuto-01-getting-started.html#creating-a-project" id="creating-a-project"><h1>Creating a project</h1></a>
<p>To start this tutorial, we will create a new project from scratch. Even though it is highly recommended to be familiar with Rust and Cargo before starting, some little reminders are always good. Let's start by running:</p>
<pre><code class="language-sh">cargo new --bin my_project
cd my_project
</code></pre>
<p>The directory you have just created should contain a <code>Cargo.toml</code> file which contains our project's metadata, plus a <code>src/main.rs</code> file which contains the Rust source code. If you have <code>src/lib.rs</code> file instead, that means that you forgot the <code>--bin</code> flag ; just rename <code>lib.rs</code> to <code>main.rs</code> then.</p>
<p>In order to use glium, you need to add it as a dependency to your <code>Cargo.toml</code> file.</p>
<pre><code class="language-toml">[dependencies]
glium = &quot;0.33&quot;
</code></pre>
<p>By default glium pulls in everything necessary to get you started. You should now have a <code>src/main.rs</code> file that looks similar to this:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, World!&quot;);
}
</code></pre></pre>
<p>It is now time to start work on the main function!</p>
<a class="header" href="tuto-01-getting-started.html#creating-a-window" id="creating-a-window"><h1>Creating a window</h1></a>
<p>The first step when creating a graphical application is to create a window. If you have ever worked with OpenGL before, you know how hard it is to do this correctly. Both window creation and context creation are platform-specific, and they are sometimes complex and tedious.</p>
<p>Initializing a simple OpenGL window with the default winit/glutin backend can be done via the following 3 steps:</p>
<ol>
<li>Creating an <code>EventLoop</code> for handling window and device events.</li>
<li>Making a new <code>SimpleWindowBuilder</code> and setting the desired parameters.</li>
<li>Calling the <code>build</code> method of hte <code>SimpleWindowBuilder</code> with a reference to the event_loop to get the <code>Window</code> and <code>Display</code>.</li>
</ol>
<p>This will open a new window, register it with the given event_loop and create a (glutin) OpenGL context and glium Display while finally returning both the window and display to you.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let event_loop = winit::event_loop::EventLoopBuilder::new().build();
    let (_window, display) = glium::backend::glutin::SimpleWindowBuilder::new().build(&amp;event_loop);
}
</code></pre></pre>
<p>If you try to run this example with <code>cargo run</code> you'll encounter a problem: as soon as the window has been created, our main function exits and the window is closed. To prevent this, we need to wait until we receive a <code>CloseRequested</code> event. We do this by calling <code>event_loop.run</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
event_loop.run(move |ev, _, control_flow| {
    match ev {
        winit::event::Event::WindowEvent { event, .. } =&gt; match event {
            winit::event::WindowEvent::CloseRequested =&gt; {
                *control_flow =  winit::event_loop::ControlFlow::Exit;
            },
            _ =&gt; (),
        },
        _ =&gt; (),
    }
});
#}</code></pre></pre>
<p>If you run the program now you should see an nice little window. The contents of the window, however, are not not very appealing. Depending on your system, it can appear black, show a random image, or just noise. We are expected to draw on the window, so the system doesn't initialize its color to a specific value.</p>
<a class="header" href="tuto-01-getting-started.html#drawing-on-the-window" id="drawing-on-the-window"><h1>Drawing on the window</h1></a>
<p>Glium and the OpenGL API work similarly to drawing software like Paint or GIMP. We begin with an empty image, then draw an object on it, then another object, then another object, etc. until we are satisfied with the result. But contrary to these programs, you don't want your users to see the intermediate steps. Only the final result should be displayed.</p>
<p>To accomplish this, OpenGL uses what is called <em>double buffering</em>. Instead of drawing directly on the window, we are drawing to an image stored in memory. Once we are finished drawing, this image is copied into the window.
This is represented in glium by the <code>Frame</code> object. When you want to start drawing something on a window, you must first call <code>display.draw()</code> to produce a new <code>Frame</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut target = display.draw();
#}</code></pre></pre>
<p>We can then use this <code>target</code> as a drawing surface. One of the operations that OpenGL and glium provide is filling the surface with a given color. This is what we are going to do.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
target.clear_color(0.0, 0.0, 1.0, 1.0);
#}</code></pre></pre>
<p>Note that to use this function, we will need to import the <code>Surface</code> trait first:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use glium::Surface;
#}</code></pre></pre>
<p>The four values that we pass to <code>clear_color</code> represent the four components of our color: red, green, blue and alpha. Only values between <code>0.0</code> and <code>1.0</code> are valid. Here we are drawing an opaque blue color.</p>
<p>As explained above, the user doesn't immediately see the blue color on the screen. At this point if we were in a game, we would most likely draw our characters, their weapons, the ground, the sky, etc. But in this tutorial we will just stop here:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
target.finish().unwrap();
#}</code></pre></pre>
<p>This call to <code>finish()</code> means that we have finished drawing. It destroys the <code>Frame</code> object and copies our background image to the window. Our window is now filled with blue.</p>
<p>Here is our full program:</p>
<pre><pre class="playpen"><code class="language-rust">use glium::Surface;

fn main() {
    let event_loop = winit::event_loop::EventLoopBuilder::new().build();
    let (_window, display) = glium::backend::glutin::SimpleWindowBuilder::new().build(&amp;event_loop);

    let mut frame = display.draw();
    frame.clear_color(0.0, 0.0, 1.0, 1.0);
    frame.finish().unwrap();

    event_loop.run(move |event, _, control_flow| {
        match event {
            winit::event::Event::WindowEvent { event, .. } =&gt; match event {
                winit::event::WindowEvent::CloseRequested =&gt; control_flow.set_exit(),
                _ =&gt; (),
            },
            _ =&gt; (),
        };
    });
}
</code></pre></pre>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="README.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="tuto-02-triangle.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="README.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="tuto-02-triangle.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
